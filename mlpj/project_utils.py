"""
Project management utilities
"""
import os
import sys
import re
import random
import contextlib
import tempfile
import collections
import pickle
import json
from typing import Optional, Any, List, Union, Dict, Callable, Sequence, Mapping
from collections.abc import Generator

import numpy as np

from . import python_utils as pu
from . import result_display, actions_looper


FINDINGS_FILENAME = 'contents.db'


class Manager(object):
    """Creates and delegates to specialist objects for actions looping, result
    display and other things.

    Args:
        project_path (str): directory for the project data; the basename will be
            taken as the project name
        seed (int, optional): random seed, will be registered in the libraries
            `numpy` and `random`
        doc (str, optional): project documentation to be displayed in the
            command line help

    Directory and file structure for the project:
    * `<project_path>/steps`: the persisted interim results of processing
      steps handled by `actions_looper` commands
    * `<project_path>/image`: the plots created with `savefig`
    * `<project_path>/html`: the HTML files generated by `result_display`
      commands like (`savefig`, `printer`), linking to the images in the image
      directory above
    * `<project_path>/html/index.html`: the default HTML page generated by
      `result_display` commands
    * `<project_path>/contents.db`: Sqlite database used by `result_display`
      commands
    """

    project_dir: str
    name: str
    db_path: str
    html_path: str
    image_path: str
    insight_path: str
    value_path: str
    seed: Optional[int]
    display: result_display.HTMLDisplay
    actions_looper: actions_looper.ActionsLooper

    def __init__(
        self, project_path: str, seed: Optional[int] = None,
        doc: Optional[str] = None
    ) -> None:
        self.project_dir = os.path.abspath(os.path.expanduser(project_path))
        pu.makedir_unless_exists(self.project_dir)
        self.name = os.path.basename(self.project_dir)

        self.db_path = os.path.join(self.project_dir, FINDINGS_FILENAME)

        for dirname in 'html image insight value'.split():
            path = os.path.join(self.project_dir, dirname)
            pu.makedir_unless_exists(path)
            setattr(self, f'{dirname}_path', path)

        self.seed = seed
        if seed is not None:
            np.random.seed(seed)
            random.seed(seed + 1)

        self.display = result_display.HTMLDisplay(
            self.db_path, self.name, self.html_path, self.image_path)

        if doc is None:
            doc = ''
        doc = f"{self.name}\n{doc}"

        steps_storage = actions_looper.PicklingStepsStorage(
            os.path.join(self.project_dir, "steps"))

        self.actions_looper = actions_looper.ActionsLooper(
            steps_storage, doc=doc)

    def as_action(self, *args, **kwargs) -> Any:
        """delegates to `actions_looper.ActionsLooper.action`"""
        return self.actions_looper.as_action(*args, **kwargs)

    def add_available(self, *args, **kwargs) -> bool:
        """delegates to `actions_looper.ActionsLooper.add_available`"""
        return self.actions_looper.add_available(*args, **kwargs)

    def add_available_from_module(self, *args, **kwargs) -> None:
        """delegates to `actions_looper.ActionsLooper.add_available_from_module`
        """
        return self.actions_looper.add_available_from_module(*args, **kwargs)

    def add_available_from_main_module(self, *args, **kwargs) -> None:
        """delegates to
        `actions_looper.ActionsLooper.add_available_from_main_module`
        """
        return self.actions_looper.add_available_from_main_module(*args, **kwargs)


    def actions_loop(self, *args, **kwargs) -> None:
        """delegates to `actions_looper.ActionsLooper.actions_loop`"""
        return self.actions_looper.actions_loop(*args, **kwargs)


    @property
    def curr_action(self) -> str:
        """delegates to `actions_looper.ActionsLooper.curr_action`"""
        return self.actions_looper.curr_action

    @property
    def curr_step(self) -> int:
        """delegates to `actions_looper.ActionsLooper.curr_step`"""
        return self.actions_looper.curr_step

    @property
    def curr_step_method(self) -> str:
        """delegates to `actions_looper.ActionsLooper.curr_step_method`"""
        return self.actions_looper.curr_step_method

    @property
    def curr_astep(self) -> str:
        """delegates to `actions_looper.ActionsLooper.curr_astep`"""
        return self.actions_looper.curr_astep

    @property
    def curr_page_name(self) -> Optional[str]:
        """delegates to `actions_looper.ActionsLooper.curr_page_name`"""
        return self.actions_looper.curr_page_name

    def execute(self, *args, **kwargs) -> None:
        """delegates to `actions_looper.ActionsLooper.execute`"""
        return self.actions_looper.execute(*args, **kwargs)

    def execute_fct_steps(self, *args, **kwargs) -> None:
        """delegates to `actions_looper.ActionsLooper.execute_fct_steps`"""
        return self.actions_looper.execute_fct_steps(*args, **kwargs)

    def read_result(self, action: str, step: int) -> Any:
        """delegates to `actions_looper.ActionsLooper.read_result`"""
        return self.actions_looper.read_result(action, step)


    def _add_dft_values(self, kwargs: Dict[str, Any]) -> None:
        """Add defaults for the arguments `dft_key` and `page_name to the
        keyword arguments if they aren't already present.

        `dft_key` defaults to `self.curr_astep`.
        `page_name` defaults to `self.page_name`.
        """
        if 'dft_key' not in kwargs:
            kwargs['dft_key'] = self.curr_astep
        if 'page_name' not in kwargs:
            page_name = self.curr_page_name
            if page_name is not None:
                kwargs['page_name'] = self.curr_page_name

    def printer(self, *args, **kwargs) -> None:
        """delegates to `result_display.HTMLDisplay.printer`"""
        self._add_dft_values(kwargs)
        return self.display.printer(*args, **kwargs)

    def html(self, *args, **kwargs) -> None:
        """delegates to `result_display.HTMLDisplay.html`"""
        self._add_dft_values(kwargs)
        return self.display.html(*args, **kwargs)

    def markdown(self, *args, **kwargs) -> None:
        """delegates to `result_display.HTMLDisplay.markdown`"""
        self._add_dft_values(kwargs)
        return self.display.markdown(*args, **kwargs)

    def print(self, *args, **kwargs) -> None:
        """delegates to `result_display.HTMLDisplay.print`"""
        self._add_dft_values(kwargs)
        return self.display.print(*args, **kwargs)

    def savefig(self, *args, **kwargs) -> None:
        """delegates to `result_display.HTMLDisplay.savefig`"""
        self._add_dft_values(kwargs)
        return self.display.savefig(*args, **kwargs)

    def add_db_entry(self, *args, **kwargs) -> None:
        """delegates to `result_display.HTMLDisplay.add_db_entry`"""
        return self.display.add_db_entry(*args, **kwargs)

    def link_text(self, *args, **kwargs) -> str:
        """delegates to `result_display.HTMLDisplay.link_text`"""
        return self.display.link_text(*args, **kwargs)

    def print_link_and_return_filepath(self, filename: str, remark: str = '') -> str:
        """Create a filepath for the given filename in the image directory and
        print an HTML link to it.

        Args:
            filename (str): filename (no directory)
            remark (str, optional): remark to print before the link text
        Returns:
            str: filepath in the image directory
        """
        filepath = os.path.join(self.image_path, filename)
        link_text = self.display.link_text(filepath, link_text=filename)
        print(f'{remark}{link_text}')
        return filepath

    def get_analysis_pdf_filepath(self, model_name: str, iteration: int =-1) -> str:
        """Filepath to save a Cyclic Boosting analysis PDF in.

        Args:
            model_name (str): model name
            iteration (int): Cyclic Boosting iteration
        Returns:
            str: filepath in the image directory
        """
        if iteration == -1:
            suffix = ""
        else:
            suffix = f"_{iteration}"
        return os.path.join(self.image_path, f"{model_name}{suffix}.pdf")

    def get_keys(self) -> List[str]:
        """delegates to `result_display.HTMLDisplay.get_keys`"""
        return self.display.get_keys()

    def del_keys(self, keys: Union[str, List[str]]) -> None:
        """delegates to `result_display.HTMLDisplay.del_keys`"""
        return self.display.del_keys(keys)

    def del_keys_like(self, regex: str) -> None:
        """delegates to `result_display.HTMLDisplay.del_keys_like`"""
        return self.display.del_keys_like(regex)

    def rename_keys(self, renamer: Callable[[str], str]) -> None:
        """delegates to `result_display.HTMLDisplay.rename_keys`"""
        return self.display.rename_keys(renamer)

    def move_keys_to_page(self, regex: str, page_name: str) -> None:
        """delegates to `result_display.HTMLDisplay.move_keys_to_page`"""
        return self.display.move_keys_to_page(regex, page_name)

    def move_keys_from_page_to_page(
        self, old_page_name: str, new_page_name: str
    ) -> None:
        """delegates to `result_display.HTMLDisplay.move_keys_from_page_to_page`
        """
        return self.display.move_keys_from_page_to_page(
            old_page_name, new_page_name)

    def get_findings(self) -> List[Any]:
        """delegates to `result_display.HTMLDisplay.db_findings"""
        return self.display.get_findings()

    def regenerate_html(self) -> None:
        """delegates to `result_display.HTMLDisplay.regenerate_html"""
        return self.display.regenerate_html()

    def call_and_printer(self, fct: Callable, *args, **kwargs) -> Any:
        """Call a function and print its output using `printer`

        Extract all keyword arguments that begin with and underscore, remove the
        underscore and pass them to `printer`.

        Args:
            fct: the function to call
            _print_call: Print the function name and its arguments as well.
            remaining params: The ones without initial underscores are
                the parameters of `fct`; the rest are params of `printer`. (The
                initial underscore is removed from them.)
        """
        kwargs_for_printer = collections.OrderedDict(
            (key[1:], value) for key, value in kwargs.items()
            if key.startswith('_') and key != '_print_call')
        kwargs_for_fct = collections.OrderedDict(
            (key, value) for key, value in kwargs.items()
            if not key.startswith('_'))

        with self.printer(**kwargs_for_printer):
            if kwargs.get('_print_call', False):
                args_s = ', '.join(
                    [str(arg) for arg in args]
                    + [f'{param}={repr(value)}'
                       for param, value in kwargs_for_fct.items()])
                print(f"calling: {fct.__name__}({args_s})")
                print()

            result = fct(*args, **kwargs_for_fct)
            print(result)

    def call_and_html(self, fct, *args, **kwargs) -> Any:
        """Same as `call_and_printer` but with `rendering='html'`"""
        kwargs['_rendering'] = 'html'
        return self.call_and_printer(fct, *args, **kwargs)

    def call_and_markdown(self, fct, *args, **kwargs) -> Any:
        """Same as `call_and_printer` but with `rendering='markdown'`"""
        kwargs['_rendering'] = 'markdown'
        return self.call_and_printer(fct, *args, **kwargs)

    def move_parts_and_link(
        self, target_dir: str,
        parts: Sequence[str] = (FINDINGS_FILENAME, 'insight')
    ) -> None:
        """For the selected paths within the project directory, call
        `pu.move_and_link`

        This is useful, for example, if you want to keep these parts in a
        repository and the project directory isn't part of it.

        Args:
            target_dir: the target directory for `pu.move_and_link`
            parts: the paths from the perspective of the project directory to
                move and link
        """
        for part in parts:
            pu.move_and_link(os.path.join(self.project_dir, part), target_dir)

    def _serialization_filepath(
        self, subdir: str, name: str, extension: Optional[str]
    ) -> str:
        """Filepath for values to be serialized"""
        if extension is None:
            filename = name
        else:
            filename = f'{name}.{extension}'
        return os.path.join(self.project_dir, subdir, filename)

    def _raise_unsupported_extension(self, extension: str) -> None:
        """Raise an exception reporting that an unsupported extension was
        used
        """
        raise ValueError(f'unsupported extension {extension}')

    def write_it(
        self, value: Any, name: str, key: Optional[str] = None,
        subdir: str = 'value', extension: str = 'pickle'
    ) -> None:
        """Serialize a value into a file

        Args:
            value: the value to serialize
            name: the serialization filename stem
            key: If provided, the serialization contents is an ordered
                dictionary and the value will be saved under this key in it. If
                the serialization file already exists, the other keys are left
                untouched.
            subdir: the subdir for the serialization file:
                'value': for data of temporary interest
                'insight': for data of permanent interest (and not too large)
                    which should be preserved in a repository
            extension: currently supported:
                'pickle': Python's pickle format (protocol 2)
                'json': indented JSON format
        """
        filepath = self._serialization_filepath(subdir, name, extension)

        data: OrderedDict
        if key is not None:
            if os.path.isfile(filepath):
                if extension == 'pickle':
                    with open(filepath, 'rb') as fin:
                        data = pickle.load(fin)
                elif extension == 'json':
                    with open(filepath, 'r') as fin:
                        data = json.load(fin)
                else:
                    self._raise_unsupported_extension(extension)
                assert isinstance(data, Mapping)
            else:
                data = collections.OrderedDict()
            data[key] = value
        else:
            data = value

        if extension == 'pickle':
            with open(filepath, 'wb') as fout:
                pickle.dump(data, fout, protocol=2)
        elif extension == 'json':
            with open(filepath, 'w') as fout:
                json.dump(data, fout, indent=2)
                fout.write('\n')
        else:
            self._raise_unsupported_extension()

    def write_insight(
        self, value: Any, name: str, key: Optional[str] = None,
        extension: str = 'pickle'
    ) -> None:
        """Convenience function for `write_it` with `subdir='insight'`"""
        self.write_it(
            value, name, key=key, subdir='insight', extension=extension)

    def read_it(
        self, name: str, key: Optional[str] = None,
        subdir: str = 'value'
    ) -> Any:
        """Deserialize a value from a file

        The file extension is automatically determined.

        Args:
            name: the serialization filename stem
            key: If provided, the serialization contents is an ordered
                dictionary and the value is saved under this key in it.
            subdir: the subdir for the serialization file:
                'value': for data of temporary interest
                'insight': for data of permanent interest (and not too large)
                    which should be preserved in a repository
        """
        filepath_stem = self._serialization_filepath(subdir, name, None)
        for extension in ('pickle', 'json'):
            filepath = f'{filepath_stem}.{extension}'
            if os.path.exists(filepath):
                break
        else:
            raise IOError(
                'no serialization with filepath stem {filepath_stem} found')

        if extension == 'pickle':
            with open(filepath, 'rb') as fin:
                data = pickle.load(fin)
        elif extension == 'json':
            with open(filepath, 'r') as fin:
                data = json.load(fin)
        else:
            self._raise_unsupported_extension(extension)

        if key is not None:
            assert isinstance(data, Mapping)
            return data[key]
        else:
            return data

    def read_insight(self, name: str, key: Optional[str] = None) -> None:
        """Convenience function for `read_it` with `subdir='insight'`"""
        return self.read_it(name, key=key, subdir='insight')


@contextlib.contextmanager
def temp_project() -> Generator[Manager]:
    """Context manager offering a temporary project

    For example for testing purposes.
    """
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Manager(tmpdir)
